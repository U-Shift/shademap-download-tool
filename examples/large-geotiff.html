<!DOCTYPE html>
<html>

<head>
    <title>Large GeoTIFF download</title>
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.css' rel='stylesheet' />

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">

    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        html,
        body,
        #map {
            height: 100%;
        }

        #loader {
            display: none;
            position: absolute;
            z-index: 9999;
            background-color: gray;
            color: white;
            text-align: center;
            line-height: 50px;

            width: 45%;
            height: auto;
            top: 42.5%;
            left: 27.5%;
            border-radius: 8px;
            padding: 8px;
        }
        #loader p {
            margin: 0;
        }

        dialog {
            -webkit-transition: all 0.2s ease-in-out 0s;
            -moz-transition: all 0.2s ease-in-out 0s;
            -ms-transition: all 0.2s ease-in-out 0s;
            transition: all 0.2s ease-in-out 0s;

            opacity: 1;
            visibility: visible;
        }
        dialog.hidden {
            opacity: 0;
            visibility: hidden;
        }
    </style>
</head>

</head>

<body>
    <div id='map'></div>
    <div id='loader'>
        <p>0%</p>
        <progress value="0" max="100"></progress>
        <small></small>
    </div>

    <dialog open id="modal-keys">
        <article>
            <header>
                <p>
                    <strong>üó∫Ô∏è ShadeMap download tool</strong>
                </p>
            </header>
            <p>
                Welcome! This tool uses Mapbox and ShadeMap services, for which you need to provide API keys. <u>You can create them for free</u>.
            </p>

            <small><a href="https://docs.mapbox.com/help/getting-started/access-tokens/" target="_blank">Mapbox API key tutorial</a></small>
            <br/>
            <small><a href="https://shademap.app/about/#" target="_blank">Shademap API key page</a> (click on "Get API key", it will be sent to your email)</small>

            <hr/>
            
            <div id="tiff-form">
                <div>
                    <small>Mapbox API key (default public token)</small>
                    <input type="text" id="key-mapbox">
                </div>

                <div>
                    <small>Shademap API key</small>
                    <input type="text" id="key-shademap">
                </div>
            </div>

            <footer>
                <button id="key-validation">Proceed</button>
            </footer>
        </article>
    </dialog>

    <dialog open id="modal-form" class="hidden">
        <article>
            <header>
                <p>
                    <strong>üó∫Ô∏è ShadeMap download tool</strong>
                </p>
            </header>
            <p>
                We are all set! üôÇ
            </p>
            <p>
                Ajust the form below with your parameters and click the download button to generate the TIFF file.
            </p>

            <hr/>
            <u class="small">
                The TIFF is generated over a square area, defined with the north-west and south-east corners coordinates, for a specic date and time, with the level of detail specified by the zoom level.
            </u>
            <br/><br/>
            
            <div id="tiff-form">
                <div>
                    <small>North-west corner latitude</small>
                    <input type="number" name="number" id="nw-lat">
                </div>

                <div>
                    <small>North-west corner longitude</small>
                    <input type="number" name="number" id="nw-lon">
                </div>

                <div>
                    <small>Shouth-east corner latitude</small>
                    <input type="number" name="number" id="se-lat">
                </div>

                <div>
                    <small>South-east corner longitude</small>
                    <input type="number" name="number" id="se-lon">
                </div>
                
                <div>
                    <small>Date(s) to consider (YYYY-MM-DD, separated by comma)</small>
                    <input type="text" id="dates">
                </div>

                <div>
                    <small>Hour(s) to consider (UTC) (HH:MM, separated by comma)</small>
                    <input type="text" id="hours">
                </div>

                <div>
                    <small>Zoom level</small>
                    <input type="number" name="number" id="zoom">
                </div>

                <div>
                    <small>Filename (defaults to stitch)</small>
                    <input type="text" id="filename">
                </div>
            </div>

            <footer>
                <button disabled id="download">Download TIFF</button>
            </footer>
        </article>
    </dialog>

    <dialog open id="modal-success" class="hidden">
        <article>
          <h2>‚úÖ Success!</h2>
          <p></p>
          <footer>
            <button class="secondary modal-close">Go back to form</button>
          </footer>
        </article>
      </dialog>

      <dialog open id="modal-error" class="hidden">
        <article>
          <h2>‚ö†Ô∏è There was an error!</h2>
          <p></p>
          <footer>
            <button class="secondary modal-close">Go back to form</button>
          </footer>
        </article>
      </dialog>
</body>
<script src="https://api.tiles.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.js"></script>
<script src='https://www.unpkg.com/mapbox-gl-shadow-simulator/dist/mapbox-gl-shadow-simulator.umd.min.js'></script>
<script src="https://cdn.jsdelivr.net/npm/geotiff@2.0.7/dist-browser/geotiff.js"></script>
<script src="./window.js"></script>
<script src="./utils.js"></script>
<script>
    const TILE_SIZE = 512;
    const loader = document.getElementById('loader');
    const dialog_keys = document.getElementById('modal-keys');
    const dialog_form = document.getElementById('modal-form');
    const dialog_success = document.getElementById('modal-success');
    const dialog_error = document.getElementById('modal-error');

    const lng2pixel = (lng, zoom) => {
        return ((lng + 180) / 360 * Math.pow(2, zoom)) * TILE_SIZE;
    }

    const lat2pixel = (lat, zoom) => {
        return ((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom)) * TILE_SIZE
    }

    const unproject = (coords, zoom) => {
        const [lat, lng] = coords;
        return [Math.floor(lng2pixel(lng, zoom)), Math.floor(lat2pixel(lat, zoom))];
    }

    const shadeMapLoaded = (shadeMap) => {
        return new Promise((res, rej) => {
            shadeMap.on('idle', res);
        });
    };

    function roundToScreenSize(innerWidth, innerHeight, nw, se, worldSize) {

        const nwM = mapboxgl.MercatorCoordinate.fromLngLat({ lng: nw[1], lat: nw[0] });
        const seM = mapboxgl.MercatorCoordinate.fromLngLat({ lng: se[1], lat: se[0] });
        const [xMin, yMin] = [nwM.x * worldSize, nwM.y * worldSize];
        const [xMax, yMax] = [seM.x * worldSize, seM.y * worldSize];

        const wSpan = xMax - xMin;
        const hSpan = yMax - yMin;

        const wScreens = Math.ceil(wSpan / innerWidth);
        const hScreens = Math.ceil(hSpan / innerHeight);

        const seMRounded = new mapboxgl.MercatorCoordinate(
            (xMin + wScreens * innerWidth) / worldSize,
            (yMin + hScreens * innerHeight) / worldSize,
            0
        );

        const newSE = seMRounded.toLngLat();

        const width = wScreens * innerWidth;
        const height = hScreens * innerHeight;

        return { width, height, wScreens, hScreens, newSE }

    }

    async function loadScreen(shadeMap, coords, zoom, worldSize) {
        const [x, y] = coords;
        map.setZoom(zoom);
        const mercX = (x + innerWidth / 2) / worldSize;
        const mercY = (y + innerHeight / 2) / worldSize;
        const merc = new mapboxgl.MercatorCoordinate(mercX, mercY, 0);
        const center = merc.toLngLat();
        map.setCenter(center);
        const smLoaded = shadeMapLoaded(shadeMap)
        const mapboxLoaded = SMUtils.mapLoaded(map);
        await Promise.all([mapboxLoaded, smLoaded]);
        return;
    }

    function coordinatesDifference(a,b) {
        if (a>0 && b>0) return Math.abs(a-b);
        if (a<0 && b<0) return Math.abs(Math.abs(a)-Math.abs(b));
        if (a==0) return Math.abs(b);
        if (b==0) return Math.abs(a);
        return Math.abs(a)+Math.abs(b)
    }

    async function download(
        data, // Exported data to download
        nw, se, width, height, cols, rows, // Area global values
        batchCols, batchRows, colStart, rowStart, colEnd, rowEnd, // Sheet batch information
        timestamp, // Timestamp is added to file name
        subarea // Subarea number for file name purposes
    ) {

        console.log("start", colStart, rowStart);
        console.log("end", colEnd, rowEnd);
        console.log("cols", cols, "batchcols", batchCols);
        console.log("rows", rows, "batchrows", batchRows);
        
        let latitudePerRow = coordinatesDifference(nw[0], se[0]) / rows;
        let latitudeStart = nw[0] - rowStart * latitudePerRow; // We start on top nw, so we go south (-)

        let longitudePerColumn = coordinatesDifference(se[1], nw[1]) / cols;
        console.log("longitudePerColumn", longitudePerColumn);
        let longitudeStart = nw[1] + colStart * longitudePerColumn; // We start on top nw, so we go east (+)

        const ModelTiepoint = [0, 0, 0, longitudeStart, latitudeStart, 0];
        const ModelPixelScale = [coordinatesDifference(se[1], nw[1]) / width, coordinatesDifference(nw[0], se[0]) / height, 0];

        console.log("ModelTiepoint", ModelTiepoint);
        console.log("ModelPixelScale", ModelPixelScale);

        const pad = (num) => String(num).padStart(2, '0');

        const metadata = {
            width: (width / cols) * batchCols,
            height: (height / rows) * batchRows,
            ModelTiepoint,
            ModelPixelScale,
            GeographicTypeGeoKey: 4326,
            // GDAL_NODATA,
            GeogCitationGeoKey: 'WGS 84',
        };
        console.log(data.length);
        console.log("Starting GeoTIFF.writeArrayBuffer...", metadata);
        const arrayBuffer = await GeoTIFF.writeArrayBuffer(
            Array.from(data),
            metadata
        );
        console.log("GeoTIFF.writeArrayBuffer finished.");
        const typedArray = new Uint8Array(arrayBuffer);
        const charCode = typedArray.reduce((all, char) => {
            return (all += String.fromCharCode(char));
        }, "");
        const base64 = btoa(charCode);
        const datauri = `data:image/tiff;base64,${base64}`;

        const link = document.createElement("a");
        link.href = datauri;

        let filename = document.getElementById("filename").value;
        if (!filename) filename = "stitch";
        let append = `_${timestamp.getFullYear()}${pad(timestamp.getMonth() + 1)}${pad(timestamp.getDate())}_${pad(timestamp.getHours())}${pad(timestamp.getMinutes())}${pad(timestamp.getSeconds())}`;
        if (subarea) append = `_part${subarea}`
        link.download = `${filename}${append}.tiff`


        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    async function main(shadeMap) {

        // Show loader and hide modal
        dialog_form.classList.add("hidden");
        loader.style.display = `block`;

        // Compute parameters
        let zoom = parseFloat(document.getElementById("zoom").value);
        let nw = [parseFloat(document.getElementById("nw-lat").value), parseFloat(document.getElementById("nw-lon").value)];
        let se = [parseFloat(document.getElementById("se-lat").value), parseFloat(document.getElementById("se-lon").value)];

        let dates = document.getElementById("dates").value.split(/,|;| /).map(v => v.trim()).filter(v => !!v);
        let hours = document.getElementById("hours").value.split(/,|;| /).map(v => v.trim()).filter(v => !!v);
        let timestamps = dates.map(d => hours.map(h => new Date(`${d}T${h}`))).flat(1);

        // Validate if there is any missing
        if (!zoom || !nw.every(v => !!v) || !se.every(v => !!v) || !dates.length || !hours.length) {
            let message = `Invalid parameters!`;
            dialog_error.getElementsByTagName("p")[0].innerHTML = message;
            dialog_error.classList.remove("hidden");
            throw new Error(message);
        }
        
        // Derived parameters
        const worldSize = TILE_SIZE * 2 ** zoom;

        const { innerWidth, innerHeight } = window;
        const [xMin, yMin] = unproject(nw, zoom);
        const [xMax, yMax] = unproject(se, zoom);

        // Area to export is divided into several screens, according to defined parameters
        const { width, height, wScreens, hScreens, newSE } = roundToScreenSize(innerWidth, innerHeight, nw, se, worldSize);
        se[0] = newSE.lat;
        se[1] = newSE.lng;

        console.log("inner width x height", innerWidth, innerHeight);
        console.log("width x height", width, height);
        console.log("screens", wScreens, hScreens);

        let screensGlobal = [];
        for (let i = 0; i < wScreens; i++) {
            for (let j = 0; j < hScreens; j++) {
                screensGlobal.push([xMin + i * innerWidth, yMin + j * innerHeight]);
            }
        }
        console.log("screens", screensGlobal);

        // Divide screens array into several batches, making sure each does not exceed MAX_ARRAY_SIZE
        // AND if changes column, must cover same rows as the previous (to avoid black areas, since the generated TIFF is a square)
        // Each batch will produce a TIFF file
        const MAX_ARRAY_SIZE = 2 ** 26;
        const windowPixels = innerHeight * innerWidth; // Pixels that the browser window covers
        const areaPixels = width * height; // Pixels covered by the area to export
        const rows = Math.ceil(height / innerHeight); // Number of sheets rows
        const cols = Math.ceil(width / innerWidth); // Number of sheets cols

        let screensBatches = []; 
        let batch = [];
        let batchSize = 0;
        let colI = 0;
        let rowI = 0;
        let colStart = 0;
        let rowStart = 0;
        let colEnd = 0;
        let rowEnd = 0;

        for (let i = 0; i<screensGlobal.length; i++) {
            // Append to batch
            batch.push(screensGlobal[i]);
            batchSize += windowPixels;
            colEnd = colI;
            rowEnd = rowI;

            // Update next index
            rowI += 1;
            if (rowI>=rows) {
                rowI = 0;
                colI += 1;
            }

            // If last screen 
            // OR next passes to next column AND (current batch did not start on first column OR array has no space for a full column)
            // # Last condition avoids black spaces because row or column were not filled totally
            if (
                i+1==screensGlobal.length || 
                colI>colStart && (rowStart>0 || rowI===0 && (batchSize + windowPixels*rows)>MAX_ARRAY_SIZE)
            ) {
                screensBatches.push({colStart, colEnd, rowStart, rowEnd, screens: batch});
                batch = [];
                batchSize = 0;

                colStart = colI;
                rowStart = rowI;
            }
        }

        console.log("Generating", screensBatches.length, "batches, on a canvas with", cols, "cols and", rows, "rows");
        console.log("screensBatches", screensBatches);

        // For each timestamp, and for every batch, generate TIFF
        let screenGlobalCounter = 0;
        for (let ti=0; ti<timestamps.length; ti++) {
            let timestamp = timestamps[ti];

            shadeMap.options.date = timestamp;
            console.log("TIMESTAMP", timestamp, "shademap", shadeMap.options);
            // TODO! Change timestamp inside shademap
    
            for (let b=0; b<screensBatches.length; b++) {
                let batch = screensBatches[b];
                let screens = batch['screens'];
    
                let batchCols = (batch['colEnd'] - batch['colStart'] + 1);
                let batchRows = batchCols==1 ? (batch['rowEnd'] - batch['rowStart'] + 1) // If on same column, just compute row difference
                    : rows; // If changes column, should have all rows
                
                // Proceed with download
                console.log("Processing batch", b, "with pixels", (width/cols*batchCols) * (height/rows*batchRows));
                const bitmap = new Uint8Array((width/cols*batchCols) * (height/rows*batchRows));
                for (let i = 0; i < screens.length; i++) {                
                    screenGlobalCounter += 1;
                    console.log("> Processing screen", screenGlobalCounter, "of", screens.length, "(", screensGlobal.length, ")");
                    let progress =  (screenGlobalCounter / screensGlobal.length / timestamps.length * 100).toFixed(0);
                    loader.getElementsByTagName("p")[0].innerHTML = `${progress}%`;
                    loader.getElementsByTagName("progress")[0].value = progress;
                    loader.getElementsByTagName("small")[0].innerHTML = `Analysing screen ${screenGlobalCounter}/${screensGlobal.length * timestamps.length} (screen batch ${b+1}/${screensBatches.length}, timestamp ${ti+1}/${timestamps.length})`;
                    
                    await loadScreen(shadeMap, screens[i], zoom, worldSize);
                    await new Promise((res, rej) => {
                        setTimeout(res, 1000);
                    });
                    const { data } = shadeMap.toGeoTiff();
                    const [x, y] = screens[i];
                    console.log("> copy x,y", x,y);
                    console.log("> copy x,y fixed", x - xMin - (((xMax-xMin)/batchCols)*batch['colStart']),y - yMin - (((yMax-yMin)/batchRows)*batch['rowStart']));
                    console.log("> area widthxheight", (width/cols)*batchCols, (height/rows)*batchRows)
                    copy(
                        data, bitmap, // Data parameters
                        innerWidth, innerHeight, // Screen width and height (px)
                        x - xMin, y - yMin, // Coordinates withint bitmap (width batchCols*batchRows cells)
                        (width/cols)*batchCols, (height/rows)*batchRows // Area width and height (px)
                    );
                }
                console.log("FINISHED batch", b, "downloading...");
                await download(
                    bitmap, 
                    nw, se, width, height, cols, rows, 
                    batchCols, batchRows, batch['colStart'], batch['rowStart'], batch['colEnd'], batch['rowEnd'],
                    timestamp,
                    screensBatches.length>1 ? b+1 : undefined,
                );
                console.log("FINISHED downloading!");
            }
        }


        // Display success 
        loader.style.display = `none`;
        dialog_form.classList.remove("hidden");
        dialog_success.getElementsByTagName("p")[0].innerHTML = "Your TIFF export was generated successfully!";
        if (timestamps.length > 1) {
            dialog_success.getElementsByTagName("p")[0].innerHTML += `<br/><br/>The TIFF files name contain the timestamp selected to allow the distinction between them.`
        }
        if (screensBatches.length>1) {
            dialog_success.getElementsByTagName("p")[0].innerHTML += `<br/><br/>The wideness of the area selected exceeds the browser processing capabilities. Do overcome this, it was divided into ${screensBatches.length} smaller and complementar areas, each corresponding to one TIFF file downloaded.`
        }
        
        dialog_success.classList.remove("hidden");
    }

    async function copy(source, destination, sw, sh, dx, dy, dw, dh) {
        for (let i = 0; i < sh; i++) {
            for (let j = 0; j < sw; j++) {
                destination[(dy + i) * dw + dx + j] = source[i * sw + j];
            }
        }
    }

    // On load
    window.onload = function() {
        // Add default values to form 
        document.getElementById("nw-lat").value = 38.735517;
        document.getElementById("nw-lon").value = -9.136205;
        document.getElementById("se-lat").value = 38.726796;
        document.getElementById("se-lon").value = -9.117215;
        document.getElementById("dates").value = "2025-06-21";
        document.getElementById("hours").value = "12:00";
        document.getElementById("zoom").value = 15;
        document.getElementById("filename").value = "stitch";

        if (localStorage.getItem("mapboxKey")) {
            document.getElementById("key-mapbox").value = localStorage.getItem("mapboxKey");
        }
        if (localStorage.getItem("shademapKey")) {
            document.getElementById("key-shademap").value = localStorage.getItem("shademapKey");
        }

        // Event binding
        dialog_success.getElementsByClassName("modal-close")[0].onclick = function() {dialog_success.classList.add("hidden");}
        dialog_error.getElementsByClassName("modal-close")[0].onclick = function() {dialog_error.classList.add("hidden");}

        document.getElementById("key-validation").onclick = function() {
            let mapboxKey = document.getElementById("key-mapbox").value;
            let shademapKey = document.getElementById("key-shademap").value;

            localStorage.setItem('mapboxKey', mapboxKey);
            localStorage.setItem("shademapKey", shademapKey);

            console.log("keys", mapboxKey, shademapKey);

            if (!mapboxKey || !shademapKey) {
                let message = `Invalid or missing keys!`;
                dialog_error.getElementsByTagName("p")[0].innerHTML = message;
                dialog_error.classList.remove("hidden");
                throw new Error(message);
            }

            // If valid, start map and show form modal
            dialog_form.classList.remove("hidden");
            dialog_keys.classList.add("hidden");

            // Initialize map
            mapboxgl.accessToken = mapboxKey;
            var map = window.map = new mapboxgl.Map({
                container: 'map',
                zoom: 15,
                center: {
                    lat: 38.735517, lng: -9.136205
                },
                style: 'mapbox://styles/mapbox/streets-v11',
                hash: true
            });

            map.on('load', async () => {
                const shadeMap = new ShadeMap({
                    apiKey: shademapKey,
                    date: new Date(), // Temporary, will be changed before download
                    color: '#ff0000',
                    opacity: 1,
                    terrainSource: {
                        maxZoom: 25,
                        tileSize: 256,
                        getSourceUrl: ({ x, y, z }) => `https://s3.amazonaws.com/elevation-tiles-prod/terrarium/${z}/${x}/${y}.png`,
                        getElevation: ({ r, g, b, a }) => (r * 256 + g + b / 256) - 32768,
                        _overzoom: 18,
                    },
                    getFeatures: async () => {
                        await SMUtils.mapLoaded(map);
                        const buildingData = map.querySourceFeatures('composite', { sourceLayer: 'building' }).filter((feature) => {
                            return feature.properties && feature.properties.underground !== "true" && (feature.properties.height || feature.properties.render_height)
                        });
                        return buildingData;
                    },
                }).addTo(map);

                const mLoaded = SMUtils.mapLoaded(map);
                const smLoaded = shadeMapLoaded(shadeMap);

                await Promise.all([mLoaded, smLoaded]);

                // Once map has loaded, enable download button
                document.getElementById("download").disabled = false;
                document.getElementById("download").onclick = function() {main(shadeMap)};
            });
        }
    }



</script>

</html>