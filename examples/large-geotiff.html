<!DOCTYPE html>
<html>

<head>
    <title>Large GeoTIFF download</title>
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.css' rel='stylesheet' />

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">

    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        html,
        body,
        #map {
            height: 100%;
        }

        #loader {
            display: none;
            position: absolute;
            z-index: 9999;
            background-color: gray;
            color: white;
            text-align: center;
            line-height: 50px;

            width: 45%;
            height: auto;
            top: 42.5%;
            left: 27.5%;
            border-radius: 8px;
            padding: 8px;
        }
        #loader p {
            margin: 0;
        }

        dialog {
            -webkit-transition: all 0.2s ease-in-out 0s;
            -moz-transition: all 0.2s ease-in-out 0s;
            -ms-transition: all 0.2s ease-in-out 0s;
            transition: all 0.2s ease-in-out 0s;

            opacity: 1;
            visibility: visible;
        }
        dialog.hidden {
            opacity: 0;
            visibility: hidden;
        }
    </style>
</head>

</head>

<body>
    <div id='map'></div>
    <div id='loader'>
        <p>0%</p>
        <progress value="0" max="100"></progress>
        <small></small>
    </div>

    <dialog open id="modal-keys">
        <article>
            <header>
                <p>
                    <strong>üó∫Ô∏è ShadeMap download tool</strong>
                </p>
            </header>
            <p>
                Welcome! This tool uses Mapbox and ShadeMap services, for which you need to provide API keys. <u>You can create them for free</u>.
            </p>

            <small><a href="https://docs.mapbox.com/help/getting-started/access-tokens/" target="_blank">Mapbox API key tutorial</a></small>
            <br/>
            <small><a href="https://shademap.app/about/#" target="_blank">Shademap API key page</a> (click on "Get API key", it will be sent to your email)</small>

            <hr/>
            
            <div id="tiff-form">
                <div>
                    <small>Mapbox API key (default public token)</small>
                    <input type="text" id="key-mapbox">
                </div>

                <div>
                    <small>Shademap API key</small>
                    <input type="text" id="key-shademap">
                </div>
            </div>

            <footer>
                <button id="key-validation">Proceed</button>
            </footer>
        </article>
    </dialog>

    <dialog open id="modal-form" class="hidden">
        <article>
            <header>
                <p>
                    <strong>üó∫Ô∏è ShadeMap download tool</strong>
                </p>
            </header>
            <p>
                We are all set! üôÇ
            </p>
            <p>
                Ajust the form below with your parameters and click the download button to generate the TIFF file.
            </p>

            <hr/>
            <u class="small">
                The TIFF is generated over a square area, defined with the north-west and south-east corners coordinates, for a specic date and time, with the level of detail specified by the zoom level.
            </u>
            <br/><br/>
            
            <div id="tiff-form">
                <div>
                    <small>North-west corner latitude</small>
                    <input type="number" name="number" id="nw-lat">
                </div>

                <div>
                    <small>North-west corner longitude</small>
                    <input type="number" name="number" id="nw-lon">
                </div>

                <div>
                    <small>Shouth-east corner latitude</small>
                    <input type="number" name="number" id="se-lat">
                </div>

                <div>
                    <small>South-east corner longitude</small>
                    <input type="number" name="number" id="se-lon">
                </div>
                
                <div>
                    <small>Timestamp to consider (UTC)</small>
                    <input type="datetime" name="datetime" id="timestamp">
                </div>

                <div>
                    <small>Zoom level</small>
                    <input type="number" name="number" id="zoom">
                </div>

                <div>
                    <small>Filename (defaults to stitch)</small>
                    <input type="text" id="filename">
                </div>
            </div>

            <footer>
                <button disabled id="download">Download TIFF</button>
            </footer>
        </article>
    </dialog>

    <dialog open id="modal-success" class="hidden">
        <article>
          <h2>‚úÖ Success!</h2>
          <p></p>
          <footer>
            <button class="secondary modal-close">Go back to form</button>
          </footer>
        </article>
      </dialog>

      <dialog open id="modal-error" class="hidden">
        <article>
          <h2>‚ö†Ô∏è There was an error!</h2>
          <p></p>
          <footer>
            <button class="secondary modal-close">Go back to form</button>
          </footer>
        </article>
      </dialog>
</body>
<script src="https://api.tiles.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.js"></script>
<script src='https://www.unpkg.com/mapbox-gl-shadow-simulator/dist/mapbox-gl-shadow-simulator.umd.min.js'></script>
<script src="https://cdn.jsdelivr.net/npm/geotiff@2.0.7/dist-browser/geotiff.js"></script>
<script src="./window.js"></script>
<script src="./utils.js"></script>
<script>
    const TILE_SIZE = 512;
    const loader = document.getElementById('loader');
    const dialog_keys = document.getElementById('modal-keys');
    const dialog_form = document.getElementById('modal-form');
    const dialog_success = document.getElementById('modal-success');
    const dialog_error = document.getElementById('modal-error');

    const lng2pixel = (lng, zoom) => {
        return ((lng + 180) / 360 * Math.pow(2, zoom)) * TILE_SIZE;
    }

    const lat2pixel = (lat, zoom) => {
        return ((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom)) * TILE_SIZE
    }

    const unproject = (coords, zoom) => {
        const [lat, lng] = coords;
        return [Math.floor(lng2pixel(lng, zoom)), Math.floor(lat2pixel(lat, zoom))];
    }

    const shadeMapLoaded = (shadeMap) => {
        return new Promise((res, rej) => {
            shadeMap.on('idle', res);
        });
    };

    function roundToScreenSize(innerWidth, innerHeight, nw, se, worldSize) {

        const nwM = mapboxgl.MercatorCoordinate.fromLngLat({ lng: nw[1], lat: nw[0] });
        const seM = mapboxgl.MercatorCoordinate.fromLngLat({ lng: se[1], lat: se[0] });
        const [xMin, yMin] = [nwM.x * worldSize, nwM.y * worldSize];
        const [xMax, yMax] = [seM.x * worldSize, seM.y * worldSize];

        const wSpan = xMax - xMin;
        const hSpan = yMax - yMin;

        const wScreens = Math.ceil(wSpan / innerWidth);
        const hScreens = Math.ceil(hSpan / innerHeight);

        const seMRounded = new mapboxgl.MercatorCoordinate(
            (xMin + wScreens * innerWidth) / worldSize,
            (yMin + hScreens * innerHeight) / worldSize,
            0
        );

        const newSE = seMRounded.toLngLat();

        const width = wScreens * innerWidth;
        const height = hScreens * innerHeight;

        return { width, height, wScreens, hScreens, newSE }

    }

    async function loadScreen(shadeMap, coords, zoom, worldSize) {
        const [x, y] = coords;
        map.setZoom(zoom);
        const mercX = (x + innerWidth / 2) / worldSize;
        const mercY = (y + innerHeight / 2) / worldSize;
        const merc = new mapboxgl.MercatorCoordinate(mercX, mercY, 0);
        const center = merc.toLngLat();
        map.setCenter(center);
        const smLoaded = shadeMapLoaded(shadeMap)
        const mapboxLoaded = SMUtils.mapLoaded(map);
        await Promise.all([mapboxLoaded, smLoaded]);
        return;
    }

    async function download(data, nw, se, width, height, subarea) {
        const ModelTiepoint = [0, 0, 0, nw[1], nw[0], 0];
        const ModelPixelScale = [(se[1] - nw[1]) / width, (nw[0] - se[0]) / height, 0];
        console.log("ModelTiepoint", ModelTiepoint);
        console.log("ModelPixelScale", ModelPixelScale);
        const metadata = {
            width,
            height,
            ModelTiepoint,
            ModelPixelScale,
            GeographicTypeGeoKey: 4326,
            // GDAL_NODATA,
            GeogCitationGeoKey: 'WGS 84',
        };
        console.log(data.length);
        console.log("Starting GeoTIFF.writeArrayBuffer...");
        const arrayBuffer = await GeoTIFF.writeArrayBuffer(
            Array.from(data),
            metadata
        );
        console.log("GeoTIFF.writeArrayBuffer finished.");
        const typedArray = new Uint8Array(arrayBuffer);
        const charCode = typedArray.reduce((all, char) => {
            return (all += String.fromCharCode(char));
        }, "");
        const base64 = btoa(charCode);
        const datauri = `data:image/tiff;base64,${base64}`;

        const link = document.createElement("a");
        link.href = datauri;

        let filename = document.getElementById("filename").value;
        if (!filename) filename = "stitch";
        let append = "";
        if (subarea) append = `_part${subarea}`
        link.download = `${filename}${append}.tiff`


        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    async function main(shadeMap) {

        // Show loader and hide modal
        dialog_form.classList.add("hidden");
        loader.style.display = `block`;

        // Compute parameters
        let zoom = parseFloat(document.getElementById("zoom").value);
        let nw = [parseFloat(document.getElementById("nw-lat").value), parseFloat(document.getElementById("nw-lon").value)];
        let se = [parseFloat(document.getElementById("se-lat").value), parseFloat(document.getElementById("se-lon").value)];
        let timestamp = new Date(document.getElementById("timestamp").value);
        
        // Derived parameters
        const worldSize = TILE_SIZE * 2 ** zoom;

        const { innerWidth, innerHeight } = window;
        const [xMin, yMin] = unproject(nw, zoom);
        const [xMax, yMax] = unproject(se, zoom);

        const { width, height, wScreens, hScreens, newSE } = roundToScreenSize(innerWidth, innerHeight, nw, se, worldSize);
        se[0] = newSE.lat;
        se[1] = newSE.lng;

        console.log("inner width x height", innerWidth, innerHeight);
        console.log("width x height", width, height);
        console.log("screens", wScreens, hScreens);

        let screensGlobal = [];
        for (let i = 0; i < wScreens; i++) {
            for (let j = 0; j < hScreens; j++) {
                screensGlobal.push([xMin + i * innerWidth, yMin + j * innerHeight]);
            }
        }
        console.log("screens", screensGlobal);

        // Divide screens array into several batches, making sure each does not exceed MAX_ARRAY_SIZE
        // Each batch will produce a TIFF file
        const MAX_ARRAY_SIZE = 2 ** 26 / 10;
        const windowPixels = innerHeight * innerWidth; // Pixels that the browser window covers
        const areaPixels = width * height; // Pixels covered by the area to export

        let screensBatches = [];
        let batchesNumber = Math.ceil(areaPixels/MAX_ARRAY_SIZE);
        let screensIndex = 0;
        console.log("Generating", batchesNumber, "batches");

        for (let i=0; i<batchesNumber; i++) {
            let batchPixels = 0;
            let batch = [];
            while (screensIndex<screensGlobal.length && batchPixels<MAX_ARRAY_SIZE) {
                batch.push(screensGlobal[screensIndex]);
                batchPixels += windowPixels;
                screensIndex += 1;
            }
            screensBatches.push(batch);
        }
        console.log("screensBatches", screensBatches);

        // For each batch, generate TIFF
        for (let b=0; b<screensBatches.length; b++) {
            let screens = screensBatches[b];
            // Proceed with download
            console.log("Processing batch", b);
            const bitmap = new Uint8Array(width * height);
            for (let i = 0; i < screens.length; i++) {
                console.log("> Processing screen", i, "of", screens.length);
                
                let progress =  (i / screens.length / screensBatches.length * 100).toFixed(0);
                loader.getElementsByTagName("p")[0].innerHTML = `${progress}%`;
                loader.getElementsByTagName("progress")[0].value = progress;
                loader.getElementsByTagName("small")[0].innerHTML = `Analysing screen ${i+1}/${screens.length}, of screen batch ${b+1}/${screensBatches.length}`;
                
                console.log(`loading screen ${i}`);
                await loadScreen(shadeMap, screens[i], zoom, worldSize);
                await new Promise((res, rej) => {
                    setTimeout(res, 1000);
                });
                const { data } = shadeMap.toGeoTiff();
                const [x, y] = screens[i];
                copy(data, bitmap, innerWidth, innerHeight, x - xMin, y - yMin, width, height);
            }
            console.log("FINISHED batch", b, "downloading...");
            await download(bitmap, nw, se, width, height, screensBatches.length>1 ? b+1 : undefined);
            console.log("FINISHED downloading!");
        }

        // Display success 
        loader.style.display = `none`;
        dialog_form.classList.remove("hidden");
        dialog_success.getElementsByTagName("p")[0].innerHTML = "Your TIFF file was generated successfully!";
        if (screensBatches.length>1) {
            dialog_success.getElementsByTagName("p")[0].innerHTML += `<br/><br/>The wideness of the area selected exceeds the browser processing capabilities. Do overcome this, it was divided into ${screensBatches.length} smaller and complementar areas, each corresponding to one TIFF file downloaded.`
        }
        
        dialog_success.classList.remove("hidden");
    }

    async function copy(source, destination, sw, sh, dx, dy, dw, dh) {
        for (let i = 0; i < sh; i++) {
            for (let j = 0; j < sw; j++) {
                destination[(dy + i) * dw + dx + j] = source[i * sw + j];
            }
        }
    }

    // On load
    window.onload = function() {
        // Add default values to form 
        document.getElementById("nw-lat").value = 38.735517;
        document.getElementById("nw-lon").value = -9.136205;
        document.getElementById("se-lat").value = 38.726796;
        document.getElementById("se-lon").value = -9.117215;
        document.getElementById("timestamp").value = new Date(Date.UTC(2025, 6, 21, 11, 0)).toISOString().slice(0,16);
        document.getElementById("zoom").value = 15;
        document.getElementById("filename").value = "stitch";

        if (localStorage.getItem("mapboxKey")) {
            document.getElementById("key-mapbox").value = localStorage.getItem("mapboxKey");
        }
        if (localStorage.getItem("shademapKey")) {
            document.getElementById("key-shademap").value = localStorage.getItem("shademapKey");
        }

        // Event binding
        dialog_success.getElementsByClassName("modal-close")[0].onclick = function() {dialog_success.classList.add("hidden");}
        dialog_error.getElementsByClassName("modal-close")[0].onclick = function() {dialog_error.classList.add("hidden");}

        document.getElementById("key-validation").onclick = function() {
            let mapboxKey = document.getElementById("key-mapbox").value;
            let shademapKey = document.getElementById("key-shademap").value;

            localStorage.setItem('mapboxKey', mapboxKey);
            localStorage.setItem("shademapKey", shademapKey);

            console.log("keys", mapboxKey, shademapKey);

            if (!mapboxKey || !shademapKey) {
                let message = `Invalid or missing keys!`;
                dialog_error.getElementsByTagName("p")[0].innerHTML = message;
                dialog_error.classList.remove("hidden");
                throw new Error(message);
            }

            // If valid, start map and show form modal
            dialog_form.classList.remove("hidden");
            dialog_keys.classList.add("hidden");

            // Initialize map
            mapboxgl.accessToken = mapboxKey;
            var map = window.map = new mapboxgl.Map({
                container: 'map',
                zoom: 15,
                center: {
                    lat: 38.735517, lng: -9.136205
                },
                style: 'mapbox://styles/mapbox/streets-v11',
                hash: true
            });

            map.on('load', async () => {
                const shadeMap = new ShadeMap({
                    apiKey: shademapKey,
                    date: new Date(Date.UTC(2025, 6, 21, 11, 0)), // 6:39PM EST
                    color: '#ff0000',
                    opacity: 1,
                    terrainSource: {
                        maxZoom: 25,
                        tileSize: 256,
                        getSourceUrl: ({ x, y, z }) => `https://s3.amazonaws.com/elevation-tiles-prod/terrarium/${z}/${x}/${y}.png`,
                        getElevation: ({ r, g, b, a }) => (r * 256 + g + b / 256) - 32768,
                        _overzoom: 18,
                    },
                    getFeatures: async () => {
                        await SMUtils.mapLoaded(map);
                        const buildingData = map.querySourceFeatures('composite', { sourceLayer: 'building' }).filter((feature) => {
                            return feature.properties && feature.properties.underground !== "true" && (feature.properties.height || feature.properties.render_height)
                        });
                        return buildingData;
                    },
                }).addTo(map);

                const mLoaded = SMUtils.mapLoaded(map);
                const smLoaded = shadeMapLoaded(shadeMap);

                await Promise.all([mLoaded, smLoaded]);

                // Once map has loaded, enable download button
                document.getElementById("download").disabled = false;
                document.getElementById("download").onclick = function() {main(shadeMap)};
            });
        }
    }



</script>

</html>