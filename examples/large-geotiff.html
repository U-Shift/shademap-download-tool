<!DOCTYPE html>
<html>

<head>
    <title>Large GeoTIFF download</title>
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.css' rel='stylesheet' />

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">

    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        html,
        body,
        #map {
            height: 100%;
        }

        #loader {
            display: none;
            position: absolute;
            width: 50px;
            height: 50px;
            top: 50%;
            left: 50%;
            margin: 0 0 -25px -25px;
            z-index: 9999;
            border-radius: 50%;
            background-color: gray;
            color: white;
            text-align: center;
            line-height: 50px;
        }

        dialog {
            -webkit-transition: all 0.2s ease-in-out 0s;
            -moz-transition: all 0.2s ease-in-out 0s;
            -ms-transition: all 0.2s ease-in-out 0s;
            transition: all 0.2s ease-in-out 0s;

            opacity: 1;
            visibility: visible;
        }
        dialog.hidden {
            opacity: 0;
            visibility: hidden;
        }
    </style>
</head>

</head>

<body>
    <div id='map'></div>
    <div id='loader'></div>

    <dialog open id="modal-form">
        <article>
            <header>
                <p>
                    <strong>üó∫Ô∏è ShadeMap download tool</strong>
                </p>
            </header>
            <p>
                Welcome! Ajust the form below with your parameters and click the download button to generate the TIFF file.
            </p>

            <hr/>
            <u class="small">
                The TIFF is generated over a square area, defined with the north-west and south-east corners coordinates, for a specic date and time, with the level of detail specified by the zoom level.
            </u>
            <br/><br/>
            
            <div id="tiff-form">
                <div>
                    <small>North-west corner latitude</small>
                    <input type="number" name="number" id="nw-lat">
                </div>

                <div>
                    <small>North-west corner longitude</small>
                    <input type="number" name="number" id="nw-lon">
                </div>

                <div>
                    <small>Shouth-east corner latitude</small>
                    <input type="number" name="number" id="se-lat">
                </div>

                <div>
                    <small>South-east corner longitude</small>
                    <input type="number" name="number" id="se-lon">
                </div>
                
                <div>
                    <small>Timestamp to consider (UTC)</small>
                    <input type="datetime" name="datetime" id="timestamp">
                </div>

                <div>
                    <small>Zoom level</small>
                    <input type="number" name="number" id="zoom">
                </div>
            </div>

            <footer>
                <button disabled id="download">Download TIFF</button>
            </footer>
        </article>
    </dialog>

    <dialog open id="modal-success" class="hidden">
        <article>
          <h2>‚úÖ Success!</h2>
          <p>
            Your TIFF file was generated successfully!
          </p>
          <footer>
            <button class="secondary modal-close">Go back to form</button>
          </footer>
        </article>
      </dialog>

      <dialog open id="modal-error" class="hidden">
        <article>
          <h2>‚ö†Ô∏è There was an error!</h2>
          <p></p>
          <footer>
            <button class="secondary modal-close">Go back to form</button>
          </footer>
        </article>
      </dialog>
</body>
<script src="https://api.tiles.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.js"></script>
<script src='https://www.unpkg.com/mapbox-gl-shadow-simulator/dist/mapbox-gl-shadow-simulator.umd.min.js'></script>
<script src="https://cdn.jsdelivr.net/npm/geotiff@2.0.7/dist-browser/geotiff.js"></script>
<script src="./window.js"></script>
<script src="./utils.js"></script>
<script>
    const TILE_SIZE = 512;
    const loader = document.getElementById('loader');
    const dialog_form = document.getElementById('modal-form');
    const dialog_success = document.getElementById('modal-success');
    const dialog_error = document.getElementById('modal-error');

    dialog_success.getElementsByClassName("modal-close")[0].onclick = function() {dialog_success.classList.add("hidden");}
    dialog_error.getElementsByClassName("modal-close")[0].onclick = function() {dialog_error.classList.add("hidden");}



    const lng2pixel = (lng, zoom) => {
        return ((lng + 180) / 360 * Math.pow(2, zoom)) * TILE_SIZE;
    }

    const lat2pixel = (lat, zoom) => {
        return ((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom)) * TILE_SIZE
    }

    const unproject = (coords, zoom) => {
        const [lat, lng] = coords;
        return [Math.floor(lng2pixel(lng, zoom)), Math.floor(lat2pixel(lat, zoom))];
    }

    const shadeMapLoaded = (shadeMap) => {
        return new Promise((res, rej) => {
            shadeMap.on('idle', res);
        });
    };

    function roundToScreenSize(nw, se, worldSize) {

        const nwM = mapboxgl.MercatorCoordinate.fromLngLat({ lng: nw[1], lat: nw[0] });
        const seM = mapboxgl.MercatorCoordinate.fromLngLat({ lng: se[1], lat: se[0] });
        const [xMin, yMin] = [nwM.x * worldSize, nwM.y * worldSize];
        const [xMax, yMax] = [seM.x * worldSize, seM.y * worldSize];

        const wSpan = xMax - xMin;
        const hSpan = yMax - yMin;

        const wScreens = Math.ceil(wSpan / innerWidth);
        const hScreens = Math.ceil(hSpan / innerHeight);

        const seMRounded = new mapboxgl.MercatorCoordinate(
            (xMin + wScreens * innerWidth) / worldSize,
            (yMin + hScreens * innerHeight) / worldSize,
            0
        );

        const newSE = seMRounded.toLngLat();

        const width = wScreens * innerWidth;
        const height = hScreens * innerHeight;

        return { width, height, wScreens, hScreens, newSE }

    }

    async function loadScreen(shadeMap, coords, zoom, worldSize) {
        const [x, y] = coords;
        map.setZoom(zoom);
        const mercX = (x + innerWidth / 2) / worldSize;
        const mercY = (y + innerHeight / 2) / worldSize;
        const merc = new mapboxgl.MercatorCoordinate(mercX, mercY, 0);
        const center = merc.toLngLat();
        map.setCenter(center);
        const smLoaded = shadeMapLoaded(shadeMap)
        const mapboxLoaded = SMUtils.mapLoaded(map);
        await Promise.all([mapboxLoaded, smLoaded]);
        return;
    }

    async function download(data, nw, se, width, height) {
        const ModelTiepoint = [0, 0, 0, nw[1], nw[0], 0];
        const ModelPixelScale = [(se[1] - nw[1]) / width, (nw[0] - se[0]) / height, 0];
        const metadata = {
            width,
            height,
            ModelTiepoint,
            ModelPixelScale,
            GeographicTypeGeoKey: 4326,
            // GDAL_NODATA,
            GeogCitationGeoKey: 'WGS 84',
        };
        console.log(data.length);
        const arrayBuffer = await GeoTIFF.writeArrayBuffer(
            Array.from(data),
            metadata
        );
        const typedArray = new Uint8Array(arrayBuffer);
        const charCode = typedArray.reduce((all, char) => {
            return (all += String.fromCharCode(char));
        }, "");
        const base64 = btoa(charCode);
        const datauri = `data:image/tiff;base64,${base64}`;

        const link = document.createElement("a");
        link.href = datauri;
        link.download = 'stitch.tiff'
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    async function main(shadeMap) {
        // Show loader and hide modal
        dialog_form.classList.add("hidden");
        loader.style.display = `block`;

        // Compute parameters
        let zoom = parseFloat(document.getElementById("zoom").value);
        let nw = [parseFloat(document.getElementById("nw-lat").value), parseFloat(document.getElementById("nw-lon").value)];
        let se = [parseFloat(document.getElementById("se-lat").value), parseFloat(document.getElementById("se-lon").value)];
        let timestamp = new Date(document.getElementById("timestamp").value);
        
        // Derived parameters
        const worldSize = TILE_SIZE * 2 ** zoom;

        const { innerWidth, innerHeight } = window;
        const [xMin, yMin] = unproject(nw, zoom);
        const [xMax, yMax] = unproject(se, zoom);

        const { width, height, wScreens, hScreens, newSE } = roundToScreenSize(nw, se, worldSize);
        se[0] = newSE.lat;
        se[1] = newSE.lng;

        const MAX_ARRAY_SIZE = 2 ** 26;
        // TODO! When exceeds, reduce size
        const pixels = width * height;
        console.log(pixels, MAX_ARRAY_SIZE);
        if (pixels > MAX_ARRAY_SIZE) {
            let message = `Bounds to large to process, reduce area by ${Math.ceil((pixels - MAX_ARRAY_SIZE) / MAX_ARRAY_SIZE * 100)}`;
            dialog_error.getElementsByTagName("p")[0].innerHTML = message;
            dialog_error.classList.remove("hidden");
            throw new Error(message);
        }

        let screens = [];
        for (let i = 0; i < wScreens; i++) {
            for (let j = 0; j < hScreens; j++) {
                screens.push([xMin + i * innerWidth, yMin + j * innerHeight]);
            }
        }

        // Proceed with download
        const bitmap = new Uint8Array(width * height);
        for (let i = 0; i < screens.length; i++) {
            loader.innerText = `${(i / screens.length * 100).toFixed(0)}%`;
            console.log(`loading screen ${i}`);
            await loadScreen(shadeMap, screens[i], zoom, worldSize);
            await new Promise((res, rej) => {
                setTimeout(res, 1000);
            });
            const { data } = shadeMap.toGeoTiff();
            const [x, y] = screens[i];
            copy(data, bitmap, innerWidth, innerHeight, x - xMin, y - yMin, width, height);
        }
        download(bitmap, nw, se, width, height);

        // Display success 
        loader.style.display = `none`;
        dialog_form.classList.remove("hidden");
        dialog_success.classList.remove("hidden");
    }

    async function copy(source, destination, sw, sh, dx, dy, dw, dh) {
        for (let i = 0; i < sh; i++) {
            for (let j = 0; j < sw; j++) {
                destination[(dy + i) * dw + dx + j] = source[i * sw + j];
            }
        }
    }

    mapboxgl.accessToken = window.MAPBOX_CRED;
    var map = window.map = new mapboxgl.Map({
        container: 'map',
        zoom: 15,
        center: {
            lat: 38.735517, lng: -9.136205
        },
        style: 'mapbox://styles/mapbox/streets-v11',
        hash: true
    });

    map.on('load', async () => {
        const shadeMap = new ShadeMap({
            apiKey: window.SHADEMAP_CRED,
            date: new Date(Date.UTC(2025, 6, 21, 11, 0)), // 6:39PM EST
            color: '#ff0000',
            opacity: 1,
            terrainSource: {
                maxZoom: 25,
                tileSize: 256,
                getSourceUrl: ({ x, y, z }) => `https://s3.amazonaws.com/elevation-tiles-prod/terrarium/${z}/${x}/${y}.png`,
                getElevation: ({ r, g, b, a }) => (r * 256 + g + b / 256) - 32768,
                _overzoom: 18,
            },
            getFeatures: async () => {
                await SMUtils.mapLoaded(map);
                const buildingData = map.querySourceFeatures('composite', { sourceLayer: 'building' }).filter((feature) => {
                    return feature.properties && feature.properties.underground !== "true" && (feature.properties.height || feature.properties.render_height)
                });
                return buildingData;
            },
        }).addTo(map);

        const mLoaded = SMUtils.mapLoaded(map);
        const smLoaded = shadeMapLoaded(shadeMap);

        
        // Add default values to form 
        document.getElementById("nw-lat").value = 38.735517;
        document.getElementById("nw-lon").value = -9.136205;
        document.getElementById("se-lat").value = 38.726796;
        document.getElementById("se-lon").value = -9.117215;
        document.getElementById("timestamp").value = new Date(Date.UTC(2025, 6, 21, 11, 0)).toISOString().slice(0,16);
        document.getElementById("zoom").value = 15;

        await Promise.all([mLoaded, smLoaded]);

        document.getElementById("download").disabled = false;
        document.getElementById("download").onclick = function() {main(shadeMap)};
    });


</script>

</html>